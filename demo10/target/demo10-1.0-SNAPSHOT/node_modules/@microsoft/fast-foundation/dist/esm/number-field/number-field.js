import { __decorate } from "tslib";
import { attr, DOM, nullableNumberConverter, observable, } from "@microsoft/fast-element";
import { keyArrowDown, keyArrowUp } from "@microsoft/fast-web-utilities";
import { StartEnd } from "../patterns/index";
import { applyMixins } from "../utilities/index";
import { DelegatesARIATextbox } from "../text-field/index";
import { FormAssociatedNumberField } from "./number-field.form-associated";
/**
 * A Number Field Custom HTML Element.
 * Based largely on the {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/number | <input type="number" /> element }.
 *
 * @public
 */
export class NumberField extends FormAssociatedNumberField {
    constructor() {
        super(...arguments);
        /**
         * When true, spin buttons will not be rendered
         * @public
         * @remarks
         * HTML Attribute: autofocus
         */
        this.hideStep = false;
        /**
         * Amount to increment or decrement the value by
         * @public
         * @remarks
         * HTMLAttribute: step
         */
        this.step = 1;
    }
    maxChanged(previousValue, nextValue) {
        var _a;
        this.max = Math.max(nextValue, (_a = this.min) !== null && _a !== void 0 ? _a : nextValue);
        const min = Math.min(this.min, this.max);
        if (this.min !== undefined && this.min !== min) {
            this.min = min;
        }
        this.valueChanged(this.value, this.value);
    }
    minChanged(previousValue, nextValue) {
        var _a;
        this.min = Math.min(nextValue, (_a = this.max) !== null && _a !== void 0 ? _a : nextValue);
        const max = Math.max(this.min, this.max);
        if (this.max !== undefined && this.max !== max) {
            this.max = max;
        }
        this.valueChanged(this.value, this.value);
    }
    /**
     *
     * @param previousValue - previous stored value
     * @param nextValue - value being updated
     */
    valueChanged(previousValue, nextValue) {
        var _a, _b;
        let value = parseFloat(nextValue);
        if (isNaN(value)) {
            value = "";
        }
        else {
            value = Math.min(value, (_a = this.max) !== null && _a !== void 0 ? _a : value);
            value = Math.max(value, (_b = this.min) !== null && _b !== void 0 ? _b : value);
        }
        this.value = value.toString();
        if (this.proxy instanceof HTMLInputElement) {
            this.proxy.value = this.value;
        }
        if (previousValue !== undefined) {
            this.$emit("input");
            this.$emit("change");
        }
    }
    /**
     * Increments the value using the step value
     *
     * @public
     */
    stepUp() {
        var _a;
        const value = parseFloat(this.value);
        const stepUpValue = isNaN(value) ? (_a = this.min) !== null && _a !== void 0 ? _a : this.step : value + this.step;
        this.value = stepUpValue.toString();
        this.control.value = this.value;
    }
    /**
     * Decrements the value using the step value
     *
     * @public
     */
    stepDown() {
        var _a;
        const value = parseFloat(this.value);
        const stepDownValue = isNaN(value)
            ? (_a = this.max) !== null && _a !== void 0 ? _a : 0 - this.step : value - this.step;
        this.value = stepDownValue.toString();
        this.control.value = this.value;
    }
    /**
     * @internal
     */
    connectedCallback() {
        super.connectedCallback();
        this.proxy.setAttribute("type", "number");
        this.validate();
        this.control.value = this.value;
        if (this.autofocus) {
            DOM.queueUpdate(() => {
                this.focus();
            });
        }
    }
    /**
     * Handles the internal control's `input` event
     * @internal
     */
    handleTextInput() {
        this.control.value = this.control.value.replace(/[^0-9\-+e.]/g, "");
        this.value = this.control.value;
    }
    /**
     * Change event handler for inner control.
     * @remarks
     * "Change" events are not `composable` so they will not
     * permeate the shadow DOM boundary. This fn effectively proxies
     * the change event, emitting a `change` event whenever the internal
     * control emits a `change` event
     * @internal
     */
    handleChange() {
        this.$emit("change");
    }
    /**
     * Handles the internal control's `keydown` event
     * @internal
     */
    handleKeyDown(e) {
        const key = e.key;
        switch (key) {
            case keyArrowUp:
                this.stepUp();
                return false;
            case keyArrowDown:
                this.stepDown();
                return false;
        }
        return true;
    }
    /**
     * Handles populating the input field with a validated value when
     *  leaving the input field.
     * @internal
     */
    handleBlur() {
        this.control.value = this.value;
    }
}
__decorate([
    attr({ attribute: "readonly", mode: "boolean" })
], NumberField.prototype, "readOnly", void 0);
__decorate([
    attr({ mode: "boolean" })
], NumberField.prototype, "autofocus", void 0);
__decorate([
    attr({ attribute: "hide-step", mode: "boolean" })
], NumberField.prototype, "hideStep", void 0);
__decorate([
    attr
], NumberField.prototype, "placeholder", void 0);
__decorate([
    attr
], NumberField.prototype, "list", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField.prototype, "maxlength", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField.prototype, "minlength", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField.prototype, "size", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField.prototype, "step", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField.prototype, "max", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField.prototype, "min", void 0);
__decorate([
    observable
], NumberField.prototype, "defaultSlottedNodes", void 0);
applyMixins(NumberField, StartEnd, DelegatesARIATextbox);
