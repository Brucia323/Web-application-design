import { __decorate } from "tslib";
import { attr, DOM, observable } from "@microsoft/fast-element";
import { getDisplayedNodes, isHTMLElement, keyArrowDown, keyArrowLeft, keyArrowRight, keyArrowUp, keyEnd, keyEnter, keyHome, } from "@microsoft/fast-web-utilities";
import { isTreeItemElement, TreeItem } from "../tree-item";
import { FoundationElement } from "../foundation-element";
/**
 * A Tree view Custom HTML Element.
 * Implements the {@link https://w3c.github.io/aria-practices/#TreeView | ARIA TreeView }.
 *
 * @public
 */
export class TreeView extends FoundationElement {
    constructor() {
        super(...arguments);
        this.handleBlur = (e) => {
            const { relatedTarget, target } = e;
            if (target instanceof HTMLElement &&
                (relatedTarget === null || !this.contains(relatedTarget))) {
                this.setAttribute("tabindex", "0");
            }
        };
        this.handleFocus = (e) => {
            const { relatedTarget, target } = e;
            if (target instanceof HTMLElement &&
                (relatedTarget === null || !this.contains(relatedTarget))) {
                const treeView = this;
                if (target === this && this.currentFocused instanceof TreeItem) {
                    TreeItem.focusItem(this.currentFocused);
                    this.currentFocused.setAttribute("tabindex", "0");
                }
                treeView.setAttribute("tabindex", "-1");
            }
        };
        this.handleKeyDown = (e) => {
            if (!this.treeItems) {
                return true;
            }
            switch (e.key) {
                case keyHome:
                    if (this.treeItems && this.treeItems.length) {
                        TreeItem.focusItem(this.treeItems[0]);
                        this.treeItems[0].setAttribute("tabindex", "0");
                    }
                    break;
                case keyEnd:
                    if (this.treeItems && this.treeItems.length) {
                        TreeItem.focusItem(this.treeItems[this.treeItems.length - 1]);
                        this.treeItems[this.treeItems.length - 1].setAttribute("tabindex", "0");
                    }
                    break;
                case keyArrowLeft:
                    if (e.target && this.isFocusableElement(e.target)) {
                        const item = e.target;
                        if (item instanceof TreeItem && item.childItemLength() > 0) {
                            item.expanded = false;
                        }
                    }
                    break;
                case keyArrowRight:
                    if (e.target && this.isFocusableElement(e.target)) {
                        const item = e.target;
                        if (item instanceof TreeItem && item.childItemLength() > 0) {
                            item.expanded = true;
                        }
                    }
                    break;
                case keyArrowDown:
                    if (e.target && this.isFocusableElement(e.target)) {
                        this.focusNextNode(1, e.target);
                    }
                    break;
                case keyArrowUp:
                    if (e.target && this.isFocusableElement(e.target)) {
                        this.focusNextNode(-1, e.target);
                    }
                    break;
                case keyEnter:
                    // In single-select trees where selection does not follow focus (see note below),
                    // the default action is typically to select the focused node.
                    this.handleSelected(e.target);
                    break;
                default:
                    return true;
            }
        };
        this.setItems = () => {
            let focusIndex = this.treeItems.findIndex(this.isSelectedElement);
            if (focusIndex === -1) {
                focusIndex = this.treeItems.findIndex(this.isFocusableElement);
            }
            for (let item = 0; item < this.treeItems.length; item++) {
                if (item === focusIndex) {
                    this.treeItems[item].setAttribute("tabindex", "0");
                    this.currentFocused = this.treeItems[item];
                }
                this.treeItems[item].addEventListener("selected-change", this.handleItemSelected);
            }
        };
        this.resetItems = () => {
            for (let item = 0; item < this.treeItems.length; item++) {
                this.treeItems[item].removeEventListener("selected-change", this.handleItemSelected);
            }
        };
        this.handleItemSelected = (e) => {
            const newSelection = e.target;
            if (newSelection !== this.currentSelected) {
                this.handleSelected(newSelection);
            }
        };
        /**
         * check if the item is focusable
         */
        this.isFocusableElement = (el) => {
            return isTreeItemElement(el);
        };
        this.isSelectedElement = (el) => {
            return el.selected;
        };
    }
    slottedTreeItemsChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
            // filter the tree items until that's done for us in the framework
            this.resetItems();
            this.treeItems = this.getVisibleNodes();
            this.setItems();
            // check if any tree items have nested items
            // if they do, apply the nested attribute
            if (this.checkForNestedItems()) {
                this.slottedTreeItems.forEach(node => {
                    if (isTreeItemElement(node)) {
                        node.nested = true;
                    }
                });
            }
        }
    }
    checkForNestedItems() {
        return this.slottedTreeItems.some((node) => {
            return isTreeItemElement(node) && node.querySelector("[role='treeitem']");
        });
    }
    connectedCallback() {
        super.connectedCallback();
        this.treeItems = this.getVisibleNodes();
        DOM.queueUpdate(() => {
            //only supporting single select
            const node = this.treeView.querySelector("[aria-selected='true']");
            if (node) {
                this.currentSelected = node;
            }
        });
    }
    focusNextNode(delta, item) {
        const visibleNodes = this.getVisibleNodes();
        if (!visibleNodes) {
            return;
        }
        const index = visibleNodes.indexOf(item);
        const lastItem = visibleNodes[index];
        if (delta < 0 && index > 0) {
            lastItem.setAttribute("tabindex", "-1");
        }
        else if (delta > 0 && index < visibleNodes.length - 1) {
            lastItem.setAttribute("tabindex", "-1");
        }
        const focusItem = visibleNodes[visibleNodes.indexOf(item) + delta];
        if (isHTMLElement(focusItem)) {
            TreeItem.focusItem(focusItem);
            focusItem.setAttribute("tabindex", "0");
            this.currentFocused = focusItem;
        }
    }
    handleSelected(item) {
        if (this.currentSelected !== item) {
            item.setAttribute("tabindex", "0");
            if (this.currentSelected instanceof TreeItem && this.currentFocused) {
                if (!item.disabled) {
                    this.currentSelected.selected = false;
                }
                this.currentFocused.setAttribute("tabindex", "-1");
            }
            if (!this.currentSelected) {
                this.slottedTreeItems.forEach((item) => {
                    if (item instanceof TreeItem) {
                        item.setAttribute("tabindex", "-1");
                    }
                });
            }
            if (!item.disabled) {
                item.selected = true;
                this.currentSelected = item;
            }
            this.currentFocused = item;
        }
    }
    getVisibleNodes() {
        return getDisplayedNodes(this, "[role='treeitem']") || [];
    }
}
__decorate([
    attr({ attribute: "render-collapsed-nodes" })
], TreeView.prototype, "renderCollapsedNodes", void 0);
__decorate([
    observable
], TreeView.prototype, "currentSelected", void 0);
__decorate([
    observable
], TreeView.prototype, "nested", void 0);
__decorate([
    observable
], TreeView.prototype, "slottedTreeItems", void 0);
